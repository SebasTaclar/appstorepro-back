import { Logger } from '../../shared/Logger';
import { ValidationError, NotFoundError } from '../../shared/exceptions';
import { ICategoryDataSource } from '../../domain/interfaces/ICategoryDataSource';
import { Category } from '../../domain/entities/Category';

export interface CreateCategoryRequest {
  name: string;
  description?: string;
}

export interface UpdateCategoryRequest {
  name?: string;
  description?: string;
}

export class CategoryService {
  private logger: Logger;
  private categoryDataSource: ICategoryDataSource;

  constructor(logger: Logger, categoryDataSource: ICategoryDataSource) {
    this.logger = logger;
    this.categoryDataSource = categoryDataSource;
  }

  async getAllCategories(query?: unknown): Promise<Category[]> {
    this.logger.logInfo('Getting all categories');

    try {
      const categories = await this.categoryDataSource.getAll(query);
      this.logger.logInfo(`Retrieved ${categories.length} categories`);
      return categories;
    } catch (error) {
      this.logger.logError('Error getting categories', error);
      throw error;
    }
  }

  async getCategoryById(id: string): Promise<Category> {
    this.logger.logInfo(`Getting category by id: ${id}`);

    if (!id) {
      throw new ValidationError('Category ID is required');
    }

    const categoryId = parseInt(id);
    if (isNaN(categoryId)) {
      throw new ValidationError('Category ID must be a valid number');
    }

    try {
      const category = await this.categoryDataSource.getById(categoryId);

      if (!category) {
        this.logger.logWarning(`Category not found with id: ${id}`);
        throw new NotFoundError('Category not found');
      }

      this.logger.logInfo(`Retrieved category: ${category.name}`);
      return category;
    } catch (error) {
      this.logger.logError(`Error getting category by id: ${id}`, error);
      throw error;
    }
  }

  async getCategoryByName(name: string): Promise<Category | null> {
    this.logger.logInfo(`Getting category by name: ${name}`);

    if (!name) {
      throw new ValidationError('Category name is required');
    }

    try {
      const category = await this.categoryDataSource.getByName(name);

      if (category) {
        this.logger.logInfo(`Retrieved category: ${category.name}`);
      } else {
        this.logger.logInfo(`Category not found with name: ${name}`);
      }

      return category;
    } catch (error) {
      this.logger.logError(`Error getting category by name: ${name}`, error);
      throw error;
    }
  }

  async createCategory(createRequest: CreateCategoryRequest): Promise<Category> {
    this.logger.logInfo(`Creating category: ${createRequest.name}`);

    if (!createRequest.name) {
      throw new ValidationError('Category name is required');
    }

    // Check if category with same name already exists
    try {
      const existingCategory = await this.categoryDataSource.getByName(createRequest.name);
      if (existingCategory) {
        this.logger.logWarning(
          `Category creation failed: name '${createRequest.name}' already exists`
        );
        throw new ValidationError('Category with this name already exists');
      }

      const categoryData: Category = {
        id: 0, // Will be generated by Prisma
        name: createRequest.name,
        description: createRequest.description,
      };

      const newCategory = await this.categoryDataSource.create(categoryData);
      this.logger.logInfo(
        `Category created successfully: ${newCategory.name} (ID: ${newCategory.id})`
      );

      return newCategory;
    } catch (error) {
      this.logger.logError(`Error creating category: ${createRequest.name}`, error);
      throw error;
    }
  }

  async updateCategory(id: string, updateRequest: UpdateCategoryRequest): Promise<Category> {
    this.logger.logInfo(`Updating category with id: ${id}`);

    if (!id) {
      throw new ValidationError('Category ID is required');
    }

    const categoryId = parseInt(id);
    if (isNaN(categoryId)) {
      throw new ValidationError('Category ID must be a valid number');
    }

    if (!updateRequest.name && updateRequest.description === undefined) {
      throw new ValidationError(
        'At least one field (name or description) must be provided for update'
      );
    }

    try {
      // Check if category exists
      const existingCategory = await this.categoryDataSource.getById(categoryId);
      if (!existingCategory) {
        this.logger.logWarning(`Category update failed: category not found with id ${id}`);
        throw new NotFoundError('Category not found');
      }

      // If updating name, check if new name already exists
      if (updateRequest.name && updateRequest.name !== existingCategory.name) {
        const categoryWithSameName = await this.categoryDataSource.getByName(updateRequest.name);
        if (categoryWithSameName && categoryWithSameName.id !== categoryId) {
          this.logger.logWarning(
            `Category update failed: name '${updateRequest.name}' already exists`
          );
          throw new ValidationError('Category with this name already exists');
        }
      }

      const updatedCategory = await this.categoryDataSource.update(categoryId, updateRequest);

      if (!updatedCategory) {
        this.logger.logError(`Category update failed: category not found with id ${id}`);
        throw new NotFoundError('Category not found');
      }

      this.logger.logInfo(`Category updated successfully: ${updatedCategory.name} (ID: ${id})`);
      return updatedCategory;
    } catch (error) {
      this.logger.logError(`Error updating category with id: ${id}`, error);
      throw error;
    }
  }

  async deleteCategory(id: string): Promise<boolean> {
    this.logger.logInfo(`Deleting category with id: ${id}`);

    if (!id) {
      throw new ValidationError('Category ID is required');
    }

    const categoryId = parseInt(id);
    if (isNaN(categoryId)) {
      throw new ValidationError('Category ID must be a valid number');
    }

    try {
      const deleted = await this.categoryDataSource.delete(categoryId);

      if (!deleted) {
        this.logger.logWarning(`Category deletion failed: category not found with id ${id}`);
        throw new NotFoundError('Category not found');
      }

      this.logger.logInfo(`Category deleted successfully with id: ${id}`);
      return true;
    } catch (error) {
      this.logger.logError(`Error deleting category with id: ${id}`, error);
      throw error;
    }
  }
}
